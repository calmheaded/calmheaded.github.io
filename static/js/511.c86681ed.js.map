{"version":3,"file":"static/js/511.c86681ed.js","mappings":"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","sources":["webpack://three-model-viewer/./node_modules/_three@0.148.0@three/examples/jsm/loaders/DRACOLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFileLoader,\n\tLoader\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tthis.decodeDracoFile( buffer, onLoad ).catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs\n\t\t};\n\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst attribute = geometryData.attributes[ i ];\n\t\t\tconst name = attribute.name;\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tgeometry.setAttribute( name, new BufferAttribute( array, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\t\t\t\t\tconst decoderBuffer = new draco.DecoderBuffer();\n\t\t\t\t\tdecoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoderBuffer );\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( decoderBuffer );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n"],"names":["_taskCache","WeakMap","DRACOLoader","constructor","manager","super","this","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","decodeDracoFile","catch","callback","attributeIDs","attributeTypes","taskConfig","useUniqueIDs","decodeGeometry","then","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","attribute","name","itemSize","setAttribute","_loadLibrary","responseType","undefined","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","debug","log","map","dispose","terminate","draco","decoder","decoderBuffer","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","self","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","destroy","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","Int8Array","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32","onModuleLoaded","DracoDecoderModule","module","Decoder","DecoderBuffer","Init","buffers","attr"],"sourceRoot":""}