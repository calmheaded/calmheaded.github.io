{"version":3,"file":"static/js/471.7da8d813.js","mappings":"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","sources":["webpack://three-model-viewer/./node_modules/_three@0.148.0@three/examples/jsm/loaders/LDrawLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.author = original.author;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.fileName = original.fileName;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet author = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingBuildingStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'Author:':\n\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tstartingBuildingStep = false;\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tauthor,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingBuildingStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tgroup.userData.author = info.author;\n\t\t\tgroup.userData.type = info.type;\n\t\t\tgroup.userData.fileName = info.fileName;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial.userData.conditionalEdgeMaterial );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n//\n\nclass LDrawLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// Initializes the materials library with default materials\n\t\tthis.setMaterials( [] );\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t\t// Material assigned to not available colors for meshes and edges\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\n\t\tthis.missingColorMaterial.name = 'Missing material';\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { color: 0xFF00FF } );\n\t\tthis.missingEdgeColorMaterial.name = 'Missing material - Edge';\n\t\tthis.missingConditionalEdgeColorMaterial = new LDrawConditionalLineMaterial( { fog: true, color: 0xFF00FF } );\n\t\tthis.missingConditionalEdgeColorMaterial.name = 'Missing material - Conditional Edge';\n\t\tthis.missingColorMaterial.userData.edgeMaterial = this.missingEdgeColorMaterial;\n\t\tthis.missingEdgeColorMaterial.userData.conditionalEdgeMaterial = this.missingConditionalEdgeColorMaterial;\n\n\t}\n\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setMaterials( materials );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\t\tgroup.userData.fileName = url;\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, onLoad ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\tgroup.userData.fileName = '';\n\t\t\t\tonLoad( group );\n\n\t\t\t} );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t\t// And return the 'missing color' material\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = material.userData.edgeMaterial;\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = material.userData.conditionalEdgeMaterial;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\tgetMainEdgeMaterial() {\n\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\n\t\treturn mat ? mat.userData.edgeMaterial : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet color = 0xFF00FF;\n\t\tlet edgeColor = 0xFF00FF;\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( ! parseLuminance( token ) ) {\n\n\t\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\t\tcase 'CODE':\n\n\t\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\t\tcolor = lineParser.getToken();\n\t\t\t\t\t\tif ( color.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tcolor = '#' + color.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! color.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\t\tedgeMaterial = edgeMaterial.userData.edgeMaterial;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CHROME':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RUBBER':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'METAL':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t\t// Not implemented\n\t\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\t\tmaterial.color.convertSRGBToLinear();\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.set( material.color ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: edgeColor,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\t\t\tedgeMaterial.color.convertSRGBToLinear();\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: edgeColor,\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.color.convertSRGBToLinear();\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.name = name + ' - Conditional Edge';\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tmaterial.userData.edgeMaterial = edgeMaterial;\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t\tfunction parseLuminance( token ) {\n\n\t\t\t// Returns success\n\n\t\t\tlet lum;\n\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\n\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlum = parseInt( token );\n\n\t\t\t}\n\n\t\t\tif ( isNaN( lum ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\tcomputeBuildingSteps( model ) {\n\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.buildingStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n"],"names":["FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","_tempVec1","LDrawConditionalLineMaterial","constructor","parameters","super","uniforms","diffuse","value","opacity","vertexShader","fragmentShader","Object","defineProperties","this","get","set","color","setValues","isLDrawConditionalLineMaterial","ConditionalLineSegments","geometry","material","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info","distances","d0","d1","push","tri","vertCount","i2","index","next","hash","rayHash","found","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","LDrawParsedCache","loader","_cache","cloneResult","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","author","subobjects","fileName","totalFaces","startingBuildingStep","materials","group","async","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","loadAsync","Error","parse","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileMap","inverted","getData","Promise","fetchData","then","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","faceMaterials","processInfoSubobjects","subobject","promises","promise","ensureDataLoaded","subobjectInfo","loadModel","catch","error","subobjectInfos","all","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","applyMatrix4","os","reverse","size","createObject","hasCachedModel","getCachedModel","processIntoMesh","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","materialLibrary","partsCache","setMaterials","missingColorMaterial","roughness","metalness","missingEdgeColorMaterial","missingConditionalEdgeColorMaterial","fog","setPartsLibraryPath","path","url","colorLineRegex","directive","load","onLoad","onProgress","onError","parseModel","computeBuildingSteps","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","c","isLineSegments","traverse","isMesh","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","mat","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","parseLuminance","toUpperCase","parseInt","isNaN","max","min","transparent","premultipliedAlpha","depthWrite","convertSRGBToLinear","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","lum","model","stepNumber","buildingStep","numBuildingSteps"],"sourceRoot":""}