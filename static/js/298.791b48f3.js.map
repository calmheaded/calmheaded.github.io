{"version":3,"file":"static/js/298.791b48f3.js","mappings":"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","sources":["webpack://three-model-viewer/./node_modules/_three@0.148.0@three/examples/jsm/loaders/STLLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tLoaderUtils,\n\tVector3\n} from 'three';\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  const loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  const mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * const mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  const materials = [];\n *  const nGeometryGroups = geometry.groups.length;\n *\n *  const colorMap = ...; // Some logic to index colors.\n *\n *  for (let i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tconst material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  const mesh = new THREE.Mesh(geometry, materials);\n */\n\n\nclass STLLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction isBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\tconst n_faces = reader.getUint32( 80, true );\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\n\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t}\n\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n\t\t\tconst reader = new DataView( data );\n\t\t\tconst faces = reader.getUint32( 80, true );\n\n\t\t\tlet r, g, b, hasColors = false, colors;\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst dataOffset = 84;\n\t\t\tconst faceLength = 12 * 4 + 2;\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\t\tconst start = dataOffset + face * faceLength;\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\tconst vertexstart = start + i * 12;\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( hasColors ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tlet faceCounter = 0;\n\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\n\t\t\tconst normal = new Vector3();\n\n\t\t\tlet result;\n\n\t\t\tlet groupCount = 0;\n\t\t\tlet startVertex = 0;\n\t\t\tlet endVertex = 0;\n\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\tconst solid = result[ 0 ];\n\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\tlet vertexCountPerFace = 0;\n\t\t\t\t\tlet normalCountPerFace = 0;\n\n\t\t\t\t\tconst text = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t}\n\n\t\t\t\tconst start = startVertex;\n\t\t\t\tconst count = endVertex - startVertex;\n\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\tgroupCount ++;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction ensureString( buffer ) {\n\n\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\treturn LoaderUtils.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction ensureBinary( buffer ) {\n\n\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t}\n\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// start\n\n\t\tconst binData = ensureBinary( data );\n\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t}\n\n}\n\nexport { STLLoader };\n"],"names":["STLLoader","constructor","manager","super","load","url","onLoad","onProgress","onError","scope","this","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","isBinary","reader","DataView","face_size","n_faces","getUint32","expect","byteLength","solid","off","matchDataViewAt","query","offset","i","il","length","getUint8","parseBinary","faces","r","g","b","colors","defaultR","defaultG","defaultB","alpha","hasColors","index","Float32Array","dataOffset","faceLength","geometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setAttribute","parseASCII","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","normal","result","groupCount","startVertex","endVertex","exec","vertexCountPerFace","normalCountPerFace","x","parseFloat","y","z","push","count","addGroup","ensureString","buffer","Uint8Array","ensureBinary","array_buffer","charCodeAt","binData"],"sourceRoot":""}