{"version":3,"file":"static/js/24.50bf17b6.js","mappings":"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","sources":["webpack://three-model-viewer/./node_modules/_three@0.148.0@three/examples/jsm/loaders/TDSLoader.js"],"sourcesContent":["import {\n\tAdditiveBlending,\n\tBufferGeometry,\n\tColor,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLoader,\n\tLoaderUtils,\n\tMatrix4,\n\tMesh,\n\tMeshPhongMaterial,\n\tTextureLoader\n} from 'three';\n\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.debug = false;\n\n\t\tthis.group = null;\n\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t}\n\n\t/**\n\t * Load 3ds file from url.\n\t *\n\t * @method load\n\t * @param {[type]} url URL for the file.\n\t * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n\t * @param {Function} onProgress onProgress callback.\n\t * @param {Function} onError onError callback.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parse arraybuffer data and load 3ds file.\n\t *\n\t * @method parse\n\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t * @param {String} path Path for external resources.\n\t * @return {Group} Group loaded from 3ds file.\n\t */\n\tparse( arraybuffer, path ) {\n\n\t\tthis.group = new Group();\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t\tthis.readFile( arraybuffer, path );\n\n\t\tfor ( let i = 0; i < this.meshes.length; i ++ ) {\n\n\t\t\tthis.group.add( this.meshes[ i ] );\n\n\t\t}\n\n\t\treturn this.group;\n\n\t}\n\n\t/**\n\t * Decode file content to read 3ds data.\n\t *\n\t * @method readFile\n\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t * @param {String} path Path for external resources.\n\t */\n\treadFile( arraybuffer, path ) {\n\n\t\tconst data = new DataView( arraybuffer );\n\t\tconst chunk = new Chunk( data, 0, this.debugMessage );\n\n\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\n\n\t\t\tlet next = chunk.readChunk();\n\n\t\t\twhile ( next ) {\n\n\t\t\t\tif ( next.id === M3D_VERSION ) {\n\n\t\t\t\t\tconst version = next.readDWord();\n\t\t\t\t\tthis.debugMessage( '3DS file version: ' + version );\n\n\t\t\t\t} else if ( next.id === MDATA ) {\n\n\t\t\t\t\tthis.readMeshData( next, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown main chunk: ' + next.hexId );\n\n\t\t\t\t}\n\n\t\t\t\tnext = chunk.readChunk();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @method readMeshData\n\t * @param {Chunk} chunk to read mesh from\n\t * @param {String} path Path for external resources.\n\t */\n\treadMeshData( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MESH_VERSION ) {\n\n\t\t\t\tconst version = + next.readDWord();\n\t\t\t\tthis.debugMessage( 'Mesh Version: ' + version );\n\n\t\t\t} else if ( next.id === MASTER_SCALE ) {\n\n\t\t\t\tconst scale = next.readFloat();\n\t\t\t\tthis.debugMessage( 'Master scale: ' + scale );\n\t\t\t\tthis.group.scale.set( scale, scale, scale );\n\n\t\t\t} else if ( next.id === NAMED_OBJECT ) {\n\n\t\t\t\tthis.debugMessage( 'Named Object' );\n\t\t\t\tthis.readNamedObject( next );\n\n\t\t\t} else if ( next.id === MAT_ENTRY ) {\n\n\t\t\t\tthis.debugMessage( 'Material' );\n\t\t\t\tthis.readMaterialEntry( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown MDATA chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read named object chunk.\n\t *\n\t * @method readNamedObject\n\t * @param {Chunk} chunk Chunk in use.\n\t */\n\treadNamedObject( chunk ) {\n\n\t\tconst name = chunk.readString();\n\n\t\tlet next = chunk.readChunk();\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === N_TRI_OBJECT ) {\n\n\t\t\t\tconst mesh = this.readMesh( next );\n\t\t\t\tmesh.name = name;\n\t\t\t\tthis.meshes.push( mesh );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown named object chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read material data chunk and add it to the material list.\n\t *\n\t * @method readMaterialEntry\n\t * @param {Chunk} chunk Chunk in use.\n\t * @param {String} path Path for external resources.\n\t */\n\treadMaterialEntry( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\t\tconst material = new MeshPhongMaterial();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_NAME ) {\n\n\t\t\t\tmaterial.name = next.readString();\n\t\t\t\tthis.debugMessage( '   Name: ' + material.name );\n\n\t\t\t} else if ( next.id === MAT_WIRE ) {\n\n\t\t\t\tthis.debugMessage( '   Wireframe' );\n\t\t\t\tmaterial.wireframe = true;\n\n\t\t\t} else if ( next.id === MAT_WIRE_SIZE ) {\n\n\t\t\t\tconst value = next.readByte();\n\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\tthis.debugMessage( '   Wireframe Thickness: ' + value );\n\n\t\t\t} else if ( next.id === MAT_TWO_SIDE ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\t\t\t\tthis.debugMessage( '   DoubleSided' );\n\n\t\t\t} else if ( next.id === MAT_ADDITIVE ) {\n\n\t\t\t\tthis.debugMessage( '   Additive Blending' );\n\t\t\t\tmaterial.blending = AdditiveBlending;\n\n\t\t\t} else if ( next.id === MAT_DIFFUSE ) {\n\n\t\t\t\tthis.debugMessage( '   Diffuse Color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SPECULAR ) {\n\n\t\t\t\tthis.debugMessage( '   Specular Color' );\n\t\t\t\tmaterial.specular = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_AMBIENT ) {\n\n\t\t\t\tthis.debugMessage( '   Ambient color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SHININESS ) {\n\n\t\t\t\tconst shininess = this.readPercentage( next );\n\t\t\t\tmaterial.shininess = shininess * 100;\n\t\t\t\tthis.debugMessage( '   Shininess : ' + shininess );\n\n\t\t\t} else if ( next.id === MAT_TRANSPARENCY ) {\n\n\t\t\t\tconst transparency = this.readPercentage( next );\n\t\t\t\tmaterial.opacity = 1 - transparency;\n\t\t\t\tthis.debugMessage( '  Transparency : ' + transparency );\n\t\t\t\tmaterial.transparent = material.opacity < 1 ? true : false;\n\n\t\t\t} else if ( next.id === MAT_TEXMAP ) {\n\n\t\t\t\tthis.debugMessage( '   ColorMap' );\n\t\t\t\tmaterial.map = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_BUMPMAP ) {\n\n\t\t\t\tthis.debugMessage( '   BumpMap' );\n\t\t\t\tmaterial.bumpMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_OPACMAP ) {\n\n\t\t\t\tthis.debugMessage( '   OpacityMap' );\n\t\t\t\tmaterial.alphaMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_SPECMAP ) {\n\n\t\t\t\tthis.debugMessage( '   SpecularMap' );\n\t\t\t\tmaterial.specularMap = this.readMap( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown material chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t\tthis.materials[ material.name ] = material;\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @method readMesh\n\t * @param {Chunk} chunk Chunk in use.\n\t * @return {Mesh} The parsed mesh.\n\t */\n\treadMesh( chunk ) {\n\n\t\tlet next = chunk.readChunk( );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst material = new MeshPhongMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.name = 'mesh';\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === POINT_ARRAY ) {\n\n\t\t\t\tconst points = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   Vertex: ' + points );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < points; i ++ )\t\t{\n\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t} else if ( next.id === FACE_ARRAY ) {\n\n\t\t\t\tthis.readFaceArray( next, mesh );\n\n\t\t\t} else if ( next.id === TEX_VERTS ) {\n\n\t\t\t\tconst texels = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   UV: ' + texels );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst uvs = [];\n\n\t\t\t\tfor ( let i = 0; i < texels; i ++ ) {\n\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t\t} else if ( next.id === MESH_MATRIX ) {\n\n\t\t\t\tthis.debugMessage( '   Tranformation Matrix (TODO)' );\n\n\t\t\t\tconst values = [];\n\t\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = next.readFloat( );\n\n\t\t\t\t}\n\n\t\t\t\tconst matrix = new Matrix4();\n\n\t\t\t\t//X Line\n\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\n\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\n\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\n\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\n\n\t\t\t\t//Y Line\n\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\n\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\n\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\n\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\n\n\t\t\t\t//Z Line\n\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\n\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\n\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\n\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\n\n\t\t\t\t//W Line\n\t\t\t\tmatrix.elements[ 12 ] = 0;\n\t\t\t\tmatrix.elements[ 13 ] = 0;\n\t\t\t\tmatrix.elements[ 14 ] = 0;\n\t\t\t\tmatrix.elements[ 15 ] = 1;\n\n\t\t\t\tmatrix.transpose();\n\n\t\t\t\tconst inverse = new Matrix4();\n\t\t\t\tinverse.copy( matrix ).invert();\n\t\t\t\tgeometry.applyMatrix4( inverse );\n\n\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown mesh chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn mesh;\n\n\t}\n\n\t/**\n\t * Read face array data chunk.\n\t *\n\t * @method readFaceArray\n\t * @param {Chunk} chunk Chunk in use.\n\t * @param {Mesh} mesh Mesh to be filled with the data read.\n\t */\n\treadFaceArray( chunk, mesh ) {\n\n\t\tconst faces = chunk.readWord( );\n\n\t\tthis.debugMessage( '   Faces: ' + faces );\n\n\t\tconst index = [];\n\n\t\tfor ( let i = 0; i < faces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ), chunk.readWord( ), chunk.readWord( ) );\n\n\t\t\tchunk.readWord( ); // visibility\n\n\t\t}\n\n\t\tmesh.geometry.setIndex( index );\n\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\n\t\twhile ( ! chunk.endOfChunk ) {\n\n\t\t\tconst subchunk = chunk.readChunk( );\n\n\t\t\tif ( subchunk.id === MSH_MAT_GROUP ) {\n\n\t\t\t\tthis.debugMessage( '      Material Group' );\n\n\t\t\t\tconst group = this.readMaterialGroup( subchunk );\n\t\t\t\tconst count = group.index.length * 3; // assuming successive indices\n\n\t\t\t\tmesh.geometry.addGroup( start, count, materialIndex );\n\n\t\t\t\tstart += count;\n\t\t\t\tmaterialIndex ++;\n\n\t\t\t\tconst material = this.materials[ group.name ];\n\n\t\t\t\tif ( Array.isArray( mesh.material ) === false ) mesh.material = [];\n\n\t\t\t\tif ( material !== undefined )\t{\n\n\t\t\t\t\tmesh.material.push( material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown face array chunk: ' + subchunk.hexId );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( mesh.material.length === 1 ) mesh.material = mesh.material[ 0 ]; // for backwards compatibility\n\n\t}\n\n\t/**\n\t * Read texture map data chunk.\n\t *\n\t * @method readMap\n\t * @param {Chunk} chunk Chunk in use.\n\t * @param {String} path Path for external resources.\n\t * @return {Texture} Texture read from this data chunk.\n\t */\n\treadMap( chunk, path ) {\n\n\t\tlet next = chunk.readChunk( );\n\t\tlet texture = {};\n\n\t\tconst loader = new TextureLoader( this.manager );\n\t\tloader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_MAPNAME ) {\n\n\t\t\t\tconst name = next.readString();\n\t\t\t\ttexture = loader.load( name );\n\n\t\t\t\tthis.debugMessage( '      File: ' + path + name );\n\n\t\t\t} else if ( next.id === MAT_MAP_UOFFSET ) {\n\n\t\t\t\ttexture.offset.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetX: ' + texture.offset.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VOFFSET ) {\n\n\t\t\t\ttexture.offset.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetY: ' + texture.offset.y );\n\n\t\t\t} else if ( next.id === MAT_MAP_USCALE ) {\n\n\t\t\t\ttexture.repeat.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatX: ' + texture.repeat.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VSCALE ) {\n\n\t\t\t\ttexture.repeat.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatY: ' + texture.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown map chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Read material group data chunk.\n\t *\n\t * @method readMaterialGroup\n\t * @param {Chunk} chunk Chunk in use.\n\t * @return {Object} Object with name and index of the object.\n\t */\n\treadMaterialGroup( chunk ) {\n\n\t\tconst name = chunk.readString();\n\t\tconst numFaces = chunk.readWord();\n\n\t\tthis.debugMessage( '         Name: ' + name );\n\t\tthis.debugMessage( '         Faces: ' + numFaces );\n\n\t\tconst index = [];\n\t\tfor ( let i = 0; i < numFaces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ) );\n\n\t\t}\n\n\t\treturn { name: name, index: index };\n\n\t}\n\n\t/**\n\t * Read a color value.\n\t *\n\t * @method readColor\n\t * @param {Chunk} chunk Chunk.\n\t * @return {Color} Color value read..\n\t */\n\treadColor( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\t\tconst color = new Color();\n\n\t\tif ( subChunk.id === COLOR_24 || subChunk.id === LIN_COLOR_24 ) {\n\n\t\t\tconst r = subChunk.readByte( );\n\t\t\tconst g = subChunk.readByte( );\n\t\t\tconst b = subChunk.readByte( );\n\n\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse if ( subChunk.id === COLOR_F || subChunk.id === LIN_COLOR_F ) {\n\n\t\t\tconst r = subChunk.readFloat( );\n\t\t\tconst g = subChunk.readFloat( );\n\t\t\tconst b = subChunk.readFloat( );\n\n\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse {\n\n\t\t\tthis.debugMessage( '      Unknown color chunk: ' + subChunk.hexId );\n\n\t\t}\n\n\t\treturn color;\n\n\t}\n\n\t/**\n\t * Read percentage value.\n\t *\n\t * @method readPercentage\n\t * @param {Chunk} chunk Chunk to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadPercentage( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\n\t\tswitch ( subChunk.id ) {\n\n\t\t\tcase INT_PERCENTAGE:\n\t\t\t\treturn ( subChunk.readShort( ) / 100 );\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT_PERCENTAGE:\n\t\t\t\treturn subChunk.readFloat( );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.debugMessage( '      Unknown percentage chunk: ' + subChunk.hexId );\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Print debug message to the console.\n\t *\n\t * Is controlled by a flag to show or hide debug messages.\n\t *\n\t * @method debugMessage\n\t * @param {Object} message Debug message to print to the console.\n\t */\n\tdebugMessage( message ) {\n\n\t\tif ( this.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t}\n\n}\n\n\n/** Read data/sub-chunks from chunk */\nclass Chunk {\n\n\t/**\n\t * Create a new chunk\n\t *\n\t * @class Chunk\n\t * @param {DataView} data DataView to read from.\n\t * @param {Number} position in data.\n\t * @param {Function} debugMessage logging callback.\n\t */\n\tconstructor( data, position, debugMessage ) {\n\n\t\tthis.data = data;\n\t\t// the offset to the begin of this chunk\n\t\tthis.offset = position;\n\t\t// the current reading position\n\t\tthis.position = position;\n\t\tthis.debugMessage = debugMessage;\n\n\t\tif ( this.debugMessage instanceof Function ) {\n\n\t\t\tthis.debugMessage = function () {};\n\n\t\t}\n\n\t\tthis.id = this.readWord();\n\t\tthis.size = this.readDWord();\n\t\tthis.end = this.offset + this.size;\n\n\t\tif ( this.end > data.byteLength ) {\n\n\t\t\tthis.debugMessage( 'Bad chunk size for chunk at ' + position );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * read a sub cchunk.\n\t *\n\t * @method readChunk\n\t * @return {Chunk | null} next sub chunk\n\t */\n\treadChunk() {\n\n\t\tif ( this.endOfChunk ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst next = new Chunk( this.data, this.position, this.debugMessage );\n\t\t\tthis.position += next.size;\n\t\t\treturn next;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * return the ID of this chunk as Hex\n\t *\n\t * @method idToString\n\t * @return {String} hex-string of id\n\t */\n\tget hexId() {\n\n\t\treturn this.id.toString( 16 );\n\n\t}\n\n\tget endOfChunk() {\n\n\t\treturn this.position >= this.end;\n\n\t}\n\n\t/**\n\t * Read byte value.\n\t *\n\t * @method readByte\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadByte() {\n\n\t\tconst v = this.data.getUint8( this.position, true );\n\t\tthis.position += 1;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit float value.\n\t *\n\t * @method readFloat\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadFloat() {\n\n\t\ttry {\n\n\t\t\tconst v = this.data.getFloat32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + this.data.byteLength );\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read 32 bit signed integer value.\n\t *\n\t * @method readInt\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadInt() {\n\n\t\tconst v = this.data.getInt32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 16 bit signed integer value.\n\t *\n\t * @method readShort\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadShort() {\n\n\t\tconst v = this.data.getInt16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 64 bit unsigned integer value.\n\t *\n\t * @method readDWord\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadDWord() {\n\n\t\tconst v = this.data.getUint32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit unsigned integer value.\n\t *\n\t * @method readWord\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadWord() {\n\n\t\tconst v = this.data.getUint16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read NULL terminated ASCII string value from chunk-pos.\n\t *\n\t * @method readString\n\t * @return {String} Data read from the dataview.\n\t */\n\treadString() {\n\n\t\tlet s = '';\n\t\tlet c = this.readByte();\n\t\twhile ( c ) {\n\n\t\t\ts += String.fromCharCode( c );\n\t\t\tc = this.readByte();\n\n\t\t}\n\n\t\treturn s;\n\n\t}\n\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4D4D;\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3DAA;\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xC23D;\nconst M3D_VERSION = 0x0002;\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3D3D;\nconst MESH_VERSION = 0x3D3E;\nconst MASTER_SCALE = 0x0100;\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xAFFF;\nconst MAT_NAME = 0xA000;\nconst MAT_AMBIENT = 0xA010;\nconst MAT_DIFFUSE = 0xA020;\nconst MAT_SPECULAR = 0xA030;\nconst MAT_SHININESS = 0xA040;\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xA050;\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xA081;\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xA083;\nconst MAT_WIRE = 0xA085;\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xA087;\nconst MAT_TEXMAP = 0xA200;\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xA210;\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xA230;\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xA204;\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xA300;\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xA354;\nconst MAT_MAP_VSCALE = 0xA356;\nconst MAT_MAP_UOFFSET = 0xA358;\nconst MAT_MAP_VOFFSET = 0xA35A;\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000;\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110;\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130;\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160;\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader };\n"],"names":["TDSLoader","constructor","manager","super","this","debug","group","materials","meshes","load","url","onLoad","onProgress","onError","scope","path","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","arraybuffer","readFile","i","length","add","DataView","chunk","Chunk","debugMessage","id","MLIBMAGIC","CMAGIC","M3DMAGIC","next","readChunk","M3D_VERSION","version","readDWord","MDATA","readMeshData","hexId","MESH_VERSION","MASTER_SCALE","scale","readFloat","set","NAMED_OBJECT","readNamedObject","MAT_ENTRY","readMaterialEntry","name","readString","N_TRI_OBJECT","mesh","readMesh","push","material","MAT_NAME","MAT_WIRE","wireframe","MAT_WIRE_SIZE","value","readByte","wireframeLinewidth","MAT_TWO_SIDE","side","MAT_ADDITIVE","blending","MAT_DIFFUSE","color","readColor","MAT_SPECULAR","specular","MAT_AMBIENT","MAT_SHININESS","shininess","readPercentage","MAT_TRANSPARENCY","transparency","opacity","transparent","MAT_TEXMAP","map","readMap","MAT_BUMPMAP","bumpMap","MAT_OPACMAP","alphaMap","MAT_SPECMAP","specularMap","geometry","POINT_ARRAY","points","readWord","vertices","setAttribute","FACE_ARRAY","readFaceArray","TEX_VERTS","texels","uvs","MESH_MATRIX","values","matrix","elements","transpose","inverse","copy","invert","applyMatrix4","decompose","position","quaternion","computeVertexNormals","faces","index","setIndex","materialIndex","start","endOfChunk","subchunk","MSH_MAT_GROUP","readMaterialGroup","count","addGroup","Array","isArray","undefined","texture","resourcePath","setCrossOrigin","crossOrigin","MAT_MAPNAME","MAT_MAP_UOFFSET","offset","x","MAT_MAP_VOFFSET","y","MAT_MAP_USCALE","repeat","MAT_MAP_VSCALE","numFaces","subChunk","COLOR_24","LIN_COLOR_24","r","g","b","setRGB","COLOR_F","LIN_COLOR_F","INT_PERCENTAGE","readShort","FLOAT_PERCENTAGE","message","log","Function","size","end","byteLength","toString","v","getUint8","getFloat32","readInt","getInt32","getInt16","getUint32","getUint16","s","c","String","fromCharCode"],"sourceRoot":""}